<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>level API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>level</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
import pygame
import os
import settings
from settings import *
from tile import Tile
from player import Player
from support import *
from random import choice, randint
from weapon import Weapon
from debug import debug
from UI import UI
from enemy import Enemy
from upgrade import Upgrade


class Level:
    &#34;&#34;&#34;
    The Level class represents a level in the game. It contains methods for creating the map,
    creating attacks, creating enemies, and running the game logic. It also handles player logic,
    checks for player death, and displays game over and win screens.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        This method initializes a Level object. It sets up the display surface, sprite groups,
        UI, upgrades, and sounds. It also calls the create_map method to create the map.
        &#34;&#34;&#34;

        # get the display surface
        self.display_surface = pygame.display.get_surface()
        self.game_paused = False

        # sprite group setup
        self.visible_sprites = YSortCameraGroup()
        self.obstacle_sprites = pygame.sprite.Group()
        self.player_sprites = pygame.sprite.Group()

        # sprites
        self.opposite_attack = None
        self.current_attack = None
        self.attack_sprites = pygame.sprite.Group()
        self.attackable_sprites = pygame.sprite.Group()
        self.collectable_sprites = pygame.sprite.Group()

        # sprite setup
        self.create_map()

        # UI setup
        self.ui = UI()
        self.upgrade = Upgrade(self.player)

        self.upgrade_performed = False

        # sounds
        self.haps = pygame.mixer.Sound(&#39;sounds/haps.mp3&#39;)
        self.haps.set_volume(0.4)
        self.victory = pygame.mixer.Sound(&#39;sounds/victory.mp3&#39;)
        self.victory.set_volume(0.4)
        self.gameOver = pygame.mixer.Sound(&#39;sounds/gameOver.wav&#39;)
        self.gameOver.set_volume(0.4)
        self.player_hit_sound = pygame.mixer.Sound(&#39;sounds/player_hit.wav&#39;)
        self.player_hit_sound.set_volume(0.3)
        self.background_music = pygame.mixer.Sound(&#39;sounds/background_music.wav&#39;)
        self.background_music.set_volume(0.1)
        self.background_music.play(loops=-1)

    def create_map(self):
        &#34;&#34;&#34;
        This method creates the map for the game. It imports the map layout and graphics from CSV files and folders,
        and creates tiles for each element in the map.
        &#34;&#34;&#34;

        layout = {
            &#39;boundary&#39;: import_csv(&#39;map/map2_FloorBlocks.csv&#39;),
            &#39;object&#39;: import_csv(&#39;map/map2_Objects.csv&#39;),
            &#39;food&#39;: import_csv(&#39;map/map2_Food.csv&#39;),
            &#39;entity&#39;: import_csv(&#39;map/map2_Entities.csv&#39;),
        }
        graphics = {
            &#39;objects&#39;: import_folder(&#39;graphics/Objects&#39;),
            &#39;food&#39;: import_folder(&#39;graphics/Food&#39;),
        }

        for style, layout in layout.items():
            for row_index, row in enumerate(layout):
                for column_index, column in enumerate(row):
                    if column != &#39;-1&#39;:
                        x = column_index * TILESIZE
                        y = row_index * TILESIZE
                        if style == &#39;boundary&#39;:
                            Tile((x, y), [self.obstacle_sprites], &#39;invisible&#39;)
                        if style == &#39;object&#39;:
                            surface = graphics[&#39;objects&#39;][int(column)]
                            Tile((x, y), [self.visible_sprites, self.obstacle_sprites], &#39;object&#39;, surface)
                        if style == &#39;food&#39;:
                            random_food_image = choice(graphics[&#39;food&#39;])
                            Tile((x, y), [self.visible_sprites, self.collectable_sprites], &#39;food&#39;, random_food_image)
                        if style == &#39;entity&#39;:
                            if column == &#39;394&#39;:
                                self.player = Player((x, y), [self.visible_sprites, self.player_sprites],
                                                     self.obstacle_sprites,
                                                     self.create_attack, self.destroy_weapon)

    def create_attack(self):
        &#34;&#34;&#34;
        This method creates an attack for the player.
        It creates a Weapon object and assigns it to the current_attack attribute.
        If the level is 3 or higher, it also creates an opposite attack.
        &#34;&#34;&#34;

        self.current_attack = Weapon(self.player, [self.visible_sprites, self.attack_sprites])
        if settings.LEVEL &gt;= 3:
            self.opposite_attack = self.current_attack.spawn_opposite_weapon(
                self.player, [self.visible_sprites, self.attack_sprites])

    def destroy_weapon(self):
        &#34;&#34;&#34;
        This method destroys the current and opposite attacks by calling the kill method on them
        and setting them to None.
        &#34;&#34;&#34;

        if self.current_attack:
            self.current_attack.kill()

        if self.opposite_attack:
            self.opposite_attack.kill()
        self.current_attack = None
        self.opposite_attack = None

    def create_enemy(self):
        &#34;&#34;&#34;
        This method creates enemies for the game. It selects a random enemy from the list of enemies
        and creates an Enemy object for it.
        &#34;&#34;&#34;

        for enemy in settings.enemies:
            enemy_name = enemy
            Enemy(enemy_name, (randint(1100, 2500), randint(600, 2900)),
                  [self.visible_sprites, self.attackable_sprites], self.obstacle_sprites, self.damage_player)

    def player_logic(self):
        &#34;&#34;&#34;
        This method handles the player logic. It checks for collisions between the player&#39;s attacks and the enemies,
        and between the player and the collectable items. If a collision is detected, it calls the appropriate methods.
        &#34;&#34;&#34;

        if self.attack_sprites:
            for attack_sprite in self.attack_sprites:
                collision_sprites = pygame.sprite.spritecollide(attack_sprite, self.attackable_sprites, False)
                if collision_sprites:
                    for target_sprite in collision_sprites:
                        target_sprite.get_damage(self.player, attack_sprite.sprite_type)
        if self.collectable_sprites:
            for collectable_sprite in self.collectable_sprites:
                collision_sprites = pygame.sprite.spritecollide(collectable_sprite, self.player_sprites, False)
                if collision_sprites:
                    for target_sprite in collision_sprites:
                        self.player.health += 30
                        collectable_sprite.kill()
                        self.haps.play()

    def damage_player(self, amount):
        &#34;&#34;&#34;
        This method damages the player. It decreases the player&#39;s health by the given amount and plays a sound.
        &#34;&#34;&#34;

        if self.player.vulnerable:
            self.player.health -= amount
            self.player_hit_sound.play()
            self.player.vulnerable = False
            self.player.hurt_time = pygame.time.get_ticks()

    def show_game_over(self):
        &#34;&#34;&#34;
        This method displays the game over screen. It fills the display surface with black, renders the game over text,
        and plays the game over sound. It then waits for 5 seconds before quitting the game.
        &#34;&#34;&#34;

        game_over_font = pygame.font.Font(None, 100)
        game_over_text = game_over_font.render(&#34;Game Over&#34;, True, (255, 0, 0))
        game_over_rect = game_over_text.get_rect(center=(WIDTH // 2, HEIGHT // 2))

        self.display_surface.fill((0, 0, 0))
        self.display_surface.blit(game_over_text, game_over_rect)
        self.background_music.stop()
        self.gameOver.play()
        pygame.display.flip()

        # Wait for 5 seconds
        pygame.time.wait(5000)

        pygame.quit()
        sys.exit()

    def show_win(self):
        &#34;&#34;&#34;
        This method displays the win screen. It fills the display surface with black, renders the win text,
        and plays the victory sound. It then waits for 5 seconds before quitting the game.
        &#34;&#34;&#34;

        win_font = pygame.font.Font(UI_FONT, 100)
        win_text = win_font.render(&#34;You WON!!!&#34;, True, (0, 255, 0))
        win_rect = win_text.get_rect(center=(WIDTH // 2, HEIGHT // 2))

        self.display_surface.fill((0, 0, 0))
        self.display_surface.blit(win_text, win_rect)
        self.background_music.stop()
        self.victory.play()
        pygame.display.flip()

        # Wait for 5 seconds
        pygame.time.wait(5000)
        pygame.quit()
        sys.exit()

    def check_win(self):
        &#34;&#34;&#34;
        This method checks if the player has won the game. If the level is 10, it calls the show_win method.
        &#34;&#34;&#34;

        if settings.LEVEL == 10:
            self.show_win()

    def check_death(self):
        &#34;&#34;&#34;
        This method checks if the player has died. If the player&#39;s health is 0 or less,
        it calls the show_game_over method.
        &#34;&#34;&#34;

        if self.player.health &lt;= 0:
            self.show_game_over()

    def run(self):
        &#34;&#34;&#34;
        This method runs the game logic. It updates the sprites, checks for player death and win, and draws the UI.
        If the game is not paused, it continues the game logic.
        &#34;&#34;&#34;

        self.visible_sprites.custom_draw(self.player)
        self.ui.draw(self.player)

        if not self.game_paused:  # Check if the game is not paused
            if not self.player.upgrade_performed:
                self.upgrade.display()
            else:
                # Continue the game logic
                if len(settings.enemies) == 0:
                    settings.LEVEL += 1
                    settings.WAVE_SIZE += 5
                    for i in range(settings.WAVE_SIZE):
                        settings.enemies.append(choice(list(enemy_data.keys())))
                    self.create_enemy()

                    # Reset the upgrade flag in the player
                    self.player.reset_upgrade_flag()

                self.visible_sprites.update()
                self.visible_sprites.enemy_update(self.player)
                self.player_logic()
                self.check_death()
                self.check_win()


class YSortCameraGroup(pygame.sprite.Group):
    &#34;&#34;&#34;
    The YSortCameraGroup class is a subclass of pygame.sprite.Group. It overrides the draw method to sort the sprites
    by their y-coordinate before drawing them. This creates a depth effect, where sprites with a higher y-coordinate
    (i.e., sprites that are lower on the screen) are drawn on top of sprites with a lower y-coordinate.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        This method initializes a YSortCameraGroup object. It calls the superclass&#39;s __init__ method and
        sets up the display surface,
        half width, half height, and offset.
        &#34;&#34;&#34;

        super().__init__()
        self.display_surface = pygame.display.get_surface()
        self.half_width = self.display_surface.get_rect().centerx
        self.half_height = self.display_surface.get_rect().centery
        self.offset = pygame.math.Vector2()

        # creating the floor
        self.floor_surface = pygame.image.load(&#39;graphics/map2.png&#39;).convert()
        self.floor_rect = self.floor_surface.get_rect(topleft=(0, 0))

    def custom_draw(self, player):
        &#34;&#34;&#34;
        This method draws the sprites in the group. It first draws the floor,
        then sorts the sprites by their y-coordinate and draws them.
        It also updates the offset based on the player&#39;s position.
        &#34;&#34;&#34;

        self.offset.x = player.rect.centerx - self.half_width
        self.offset.y = player.rect.centery - self.half_height

        # drawing the floor
        self.display_surface.blit(self.floor_surface, self.floor_rect.topleft - self.offset)

        for sprite in sorted(self.sprites(), key=lambda sprite: sprite.rect.centery):
            offset_pos = sprite.rect.topleft - self.offset
            self.display_surface.blit(sprite.image, offset_pos)

    def enemy_update(self, player):
        &#34;&#34;&#34;
        This method updates the enemies in the group.
        It gets the enemy sprites from the group and calls their enemy_update method.
        &#34;&#34;&#34;

        enemy_sprites = [sprite for sprite in self.sprites() if hasattr(sprite, &#39;sprite_type&#39;)
                         and sprite.sprite_type == &#39;enemy&#39;]
        for enemy in enemy_sprites:
            enemy.enemy_update(player)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="level.Level"><code class="flex name class">
<span>class <span class="ident">Level</span></span>
</code></dt>
<dd>
<div class="desc"><p>The Level class represents a level in the game. It contains methods for creating the map,
creating attacks, creating enemies, and running the game logic. It also handles player logic,
checks for player death, and displays game over and win screens.</p>
<p>This method initializes a Level object. It sets up the display surface, sprite groups,
UI, upgrades, and sounds. It also calls the create_map method to create the map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Level:
    &#34;&#34;&#34;
    The Level class represents a level in the game. It contains methods for creating the map,
    creating attacks, creating enemies, and running the game logic. It also handles player logic,
    checks for player death, and displays game over and win screens.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        This method initializes a Level object. It sets up the display surface, sprite groups,
        UI, upgrades, and sounds. It also calls the create_map method to create the map.
        &#34;&#34;&#34;

        # get the display surface
        self.display_surface = pygame.display.get_surface()
        self.game_paused = False

        # sprite group setup
        self.visible_sprites = YSortCameraGroup()
        self.obstacle_sprites = pygame.sprite.Group()
        self.player_sprites = pygame.sprite.Group()

        # sprites
        self.opposite_attack = None
        self.current_attack = None
        self.attack_sprites = pygame.sprite.Group()
        self.attackable_sprites = pygame.sprite.Group()
        self.collectable_sprites = pygame.sprite.Group()

        # sprite setup
        self.create_map()

        # UI setup
        self.ui = UI()
        self.upgrade = Upgrade(self.player)

        self.upgrade_performed = False

        # sounds
        self.haps = pygame.mixer.Sound(&#39;sounds/haps.mp3&#39;)
        self.haps.set_volume(0.4)
        self.victory = pygame.mixer.Sound(&#39;sounds/victory.mp3&#39;)
        self.victory.set_volume(0.4)
        self.gameOver = pygame.mixer.Sound(&#39;sounds/gameOver.wav&#39;)
        self.gameOver.set_volume(0.4)
        self.player_hit_sound = pygame.mixer.Sound(&#39;sounds/player_hit.wav&#39;)
        self.player_hit_sound.set_volume(0.3)
        self.background_music = pygame.mixer.Sound(&#39;sounds/background_music.wav&#39;)
        self.background_music.set_volume(0.1)
        self.background_music.play(loops=-1)

    def create_map(self):
        &#34;&#34;&#34;
        This method creates the map for the game. It imports the map layout and graphics from CSV files and folders,
        and creates tiles for each element in the map.
        &#34;&#34;&#34;

        layout = {
            &#39;boundary&#39;: import_csv(&#39;map/map2_FloorBlocks.csv&#39;),
            &#39;object&#39;: import_csv(&#39;map/map2_Objects.csv&#39;),
            &#39;food&#39;: import_csv(&#39;map/map2_Food.csv&#39;),
            &#39;entity&#39;: import_csv(&#39;map/map2_Entities.csv&#39;),
        }
        graphics = {
            &#39;objects&#39;: import_folder(&#39;graphics/Objects&#39;),
            &#39;food&#39;: import_folder(&#39;graphics/Food&#39;),
        }

        for style, layout in layout.items():
            for row_index, row in enumerate(layout):
                for column_index, column in enumerate(row):
                    if column != &#39;-1&#39;:
                        x = column_index * TILESIZE
                        y = row_index * TILESIZE
                        if style == &#39;boundary&#39;:
                            Tile((x, y), [self.obstacle_sprites], &#39;invisible&#39;)
                        if style == &#39;object&#39;:
                            surface = graphics[&#39;objects&#39;][int(column)]
                            Tile((x, y), [self.visible_sprites, self.obstacle_sprites], &#39;object&#39;, surface)
                        if style == &#39;food&#39;:
                            random_food_image = choice(graphics[&#39;food&#39;])
                            Tile((x, y), [self.visible_sprites, self.collectable_sprites], &#39;food&#39;, random_food_image)
                        if style == &#39;entity&#39;:
                            if column == &#39;394&#39;:
                                self.player = Player((x, y), [self.visible_sprites, self.player_sprites],
                                                     self.obstacle_sprites,
                                                     self.create_attack, self.destroy_weapon)

    def create_attack(self):
        &#34;&#34;&#34;
        This method creates an attack for the player.
        It creates a Weapon object and assigns it to the current_attack attribute.
        If the level is 3 or higher, it also creates an opposite attack.
        &#34;&#34;&#34;

        self.current_attack = Weapon(self.player, [self.visible_sprites, self.attack_sprites])
        if settings.LEVEL &gt;= 3:
            self.opposite_attack = self.current_attack.spawn_opposite_weapon(
                self.player, [self.visible_sprites, self.attack_sprites])

    def destroy_weapon(self):
        &#34;&#34;&#34;
        This method destroys the current and opposite attacks by calling the kill method on them
        and setting them to None.
        &#34;&#34;&#34;

        if self.current_attack:
            self.current_attack.kill()

        if self.opposite_attack:
            self.opposite_attack.kill()
        self.current_attack = None
        self.opposite_attack = None

    def create_enemy(self):
        &#34;&#34;&#34;
        This method creates enemies for the game. It selects a random enemy from the list of enemies
        and creates an Enemy object for it.
        &#34;&#34;&#34;

        for enemy in settings.enemies:
            enemy_name = enemy
            Enemy(enemy_name, (randint(1100, 2500), randint(600, 2900)),
                  [self.visible_sprites, self.attackable_sprites], self.obstacle_sprites, self.damage_player)

    def player_logic(self):
        &#34;&#34;&#34;
        This method handles the player logic. It checks for collisions between the player&#39;s attacks and the enemies,
        and between the player and the collectable items. If a collision is detected, it calls the appropriate methods.
        &#34;&#34;&#34;

        if self.attack_sprites:
            for attack_sprite in self.attack_sprites:
                collision_sprites = pygame.sprite.spritecollide(attack_sprite, self.attackable_sprites, False)
                if collision_sprites:
                    for target_sprite in collision_sprites:
                        target_sprite.get_damage(self.player, attack_sprite.sprite_type)
        if self.collectable_sprites:
            for collectable_sprite in self.collectable_sprites:
                collision_sprites = pygame.sprite.spritecollide(collectable_sprite, self.player_sprites, False)
                if collision_sprites:
                    for target_sprite in collision_sprites:
                        self.player.health += 30
                        collectable_sprite.kill()
                        self.haps.play()

    def damage_player(self, amount):
        &#34;&#34;&#34;
        This method damages the player. It decreases the player&#39;s health by the given amount and plays a sound.
        &#34;&#34;&#34;

        if self.player.vulnerable:
            self.player.health -= amount
            self.player_hit_sound.play()
            self.player.vulnerable = False
            self.player.hurt_time = pygame.time.get_ticks()

    def show_game_over(self):
        &#34;&#34;&#34;
        This method displays the game over screen. It fills the display surface with black, renders the game over text,
        and plays the game over sound. It then waits for 5 seconds before quitting the game.
        &#34;&#34;&#34;

        game_over_font = pygame.font.Font(None, 100)
        game_over_text = game_over_font.render(&#34;Game Over&#34;, True, (255, 0, 0))
        game_over_rect = game_over_text.get_rect(center=(WIDTH // 2, HEIGHT // 2))

        self.display_surface.fill((0, 0, 0))
        self.display_surface.blit(game_over_text, game_over_rect)
        self.background_music.stop()
        self.gameOver.play()
        pygame.display.flip()

        # Wait for 5 seconds
        pygame.time.wait(5000)

        pygame.quit()
        sys.exit()

    def show_win(self):
        &#34;&#34;&#34;
        This method displays the win screen. It fills the display surface with black, renders the win text,
        and plays the victory sound. It then waits for 5 seconds before quitting the game.
        &#34;&#34;&#34;

        win_font = pygame.font.Font(UI_FONT, 100)
        win_text = win_font.render(&#34;You WON!!!&#34;, True, (0, 255, 0))
        win_rect = win_text.get_rect(center=(WIDTH // 2, HEIGHT // 2))

        self.display_surface.fill((0, 0, 0))
        self.display_surface.blit(win_text, win_rect)
        self.background_music.stop()
        self.victory.play()
        pygame.display.flip()

        # Wait for 5 seconds
        pygame.time.wait(5000)
        pygame.quit()
        sys.exit()

    def check_win(self):
        &#34;&#34;&#34;
        This method checks if the player has won the game. If the level is 10, it calls the show_win method.
        &#34;&#34;&#34;

        if settings.LEVEL == 10:
            self.show_win()

    def check_death(self):
        &#34;&#34;&#34;
        This method checks if the player has died. If the player&#39;s health is 0 or less,
        it calls the show_game_over method.
        &#34;&#34;&#34;

        if self.player.health &lt;= 0:
            self.show_game_over()

    def run(self):
        &#34;&#34;&#34;
        This method runs the game logic. It updates the sprites, checks for player death and win, and draws the UI.
        If the game is not paused, it continues the game logic.
        &#34;&#34;&#34;

        self.visible_sprites.custom_draw(self.player)
        self.ui.draw(self.player)

        if not self.game_paused:  # Check if the game is not paused
            if not self.player.upgrade_performed:
                self.upgrade.display()
            else:
                # Continue the game logic
                if len(settings.enemies) == 0:
                    settings.LEVEL += 1
                    settings.WAVE_SIZE += 5
                    for i in range(settings.WAVE_SIZE):
                        settings.enemies.append(choice(list(enemy_data.keys())))
                    self.create_enemy()

                    # Reset the upgrade flag in the player
                    self.player.reset_upgrade_flag()

                self.visible_sprites.update()
                self.visible_sprites.enemy_update(self.player)
                self.player_logic()
                self.check_death()
                self.check_win()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="level.Level.check_death"><code class="name flex">
<span>def <span class="ident">check_death</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method checks if the player has died. If the player's health is 0 or less,
it calls the show_game_over method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_death(self):
    &#34;&#34;&#34;
    This method checks if the player has died. If the player&#39;s health is 0 or less,
    it calls the show_game_over method.
    &#34;&#34;&#34;

    if self.player.health &lt;= 0:
        self.show_game_over()</code></pre>
</details>
</dd>
<dt id="level.Level.check_win"><code class="name flex">
<span>def <span class="ident">check_win</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method checks if the player has won the game. If the level is 10, it calls the show_win method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_win(self):
    &#34;&#34;&#34;
    This method checks if the player has won the game. If the level is 10, it calls the show_win method.
    &#34;&#34;&#34;

    if settings.LEVEL == 10:
        self.show_win()</code></pre>
</details>
</dd>
<dt id="level.Level.create_attack"><code class="name flex">
<span>def <span class="ident">create_attack</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method creates an attack for the player.
It creates a Weapon object and assigns it to the current_attack attribute.
If the level is 3 or higher, it also creates an opposite attack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_attack(self):
    &#34;&#34;&#34;
    This method creates an attack for the player.
    It creates a Weapon object and assigns it to the current_attack attribute.
    If the level is 3 or higher, it also creates an opposite attack.
    &#34;&#34;&#34;

    self.current_attack = Weapon(self.player, [self.visible_sprites, self.attack_sprites])
    if settings.LEVEL &gt;= 3:
        self.opposite_attack = self.current_attack.spawn_opposite_weapon(
            self.player, [self.visible_sprites, self.attack_sprites])</code></pre>
</details>
</dd>
<dt id="level.Level.create_enemy"><code class="name flex">
<span>def <span class="ident">create_enemy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method creates enemies for the game. It selects a random enemy from the list of enemies
and creates an Enemy object for it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_enemy(self):
    &#34;&#34;&#34;
    This method creates enemies for the game. It selects a random enemy from the list of enemies
    and creates an Enemy object for it.
    &#34;&#34;&#34;

    for enemy in settings.enemies:
        enemy_name = enemy
        Enemy(enemy_name, (randint(1100, 2500), randint(600, 2900)),
              [self.visible_sprites, self.attackable_sprites], self.obstacle_sprites, self.damage_player)</code></pre>
</details>
</dd>
<dt id="level.Level.create_map"><code class="name flex">
<span>def <span class="ident">create_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method creates the map for the game. It imports the map layout and graphics from CSV files and folders,
and creates tiles for each element in the map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_map(self):
    &#34;&#34;&#34;
    This method creates the map for the game. It imports the map layout and graphics from CSV files and folders,
    and creates tiles for each element in the map.
    &#34;&#34;&#34;

    layout = {
        &#39;boundary&#39;: import_csv(&#39;map/map2_FloorBlocks.csv&#39;),
        &#39;object&#39;: import_csv(&#39;map/map2_Objects.csv&#39;),
        &#39;food&#39;: import_csv(&#39;map/map2_Food.csv&#39;),
        &#39;entity&#39;: import_csv(&#39;map/map2_Entities.csv&#39;),
    }
    graphics = {
        &#39;objects&#39;: import_folder(&#39;graphics/Objects&#39;),
        &#39;food&#39;: import_folder(&#39;graphics/Food&#39;),
    }

    for style, layout in layout.items():
        for row_index, row in enumerate(layout):
            for column_index, column in enumerate(row):
                if column != &#39;-1&#39;:
                    x = column_index * TILESIZE
                    y = row_index * TILESIZE
                    if style == &#39;boundary&#39;:
                        Tile((x, y), [self.obstacle_sprites], &#39;invisible&#39;)
                    if style == &#39;object&#39;:
                        surface = graphics[&#39;objects&#39;][int(column)]
                        Tile((x, y), [self.visible_sprites, self.obstacle_sprites], &#39;object&#39;, surface)
                    if style == &#39;food&#39;:
                        random_food_image = choice(graphics[&#39;food&#39;])
                        Tile((x, y), [self.visible_sprites, self.collectable_sprites], &#39;food&#39;, random_food_image)
                    if style == &#39;entity&#39;:
                        if column == &#39;394&#39;:
                            self.player = Player((x, y), [self.visible_sprites, self.player_sprites],
                                                 self.obstacle_sprites,
                                                 self.create_attack, self.destroy_weapon)</code></pre>
</details>
</dd>
<dt id="level.Level.damage_player"><code class="name flex">
<span>def <span class="ident">damage_player</span></span>(<span>self, amount)</span>
</code></dt>
<dd>
<div class="desc"><p>This method damages the player. It decreases the player's health by the given amount and plays a sound.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def damage_player(self, amount):
    &#34;&#34;&#34;
    This method damages the player. It decreases the player&#39;s health by the given amount and plays a sound.
    &#34;&#34;&#34;

    if self.player.vulnerable:
        self.player.health -= amount
        self.player_hit_sound.play()
        self.player.vulnerable = False
        self.player.hurt_time = pygame.time.get_ticks()</code></pre>
</details>
</dd>
<dt id="level.Level.destroy_weapon"><code class="name flex">
<span>def <span class="ident">destroy_weapon</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method destroys the current and opposite attacks by calling the kill method on them
and setting them to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy_weapon(self):
    &#34;&#34;&#34;
    This method destroys the current and opposite attacks by calling the kill method on them
    and setting them to None.
    &#34;&#34;&#34;

    if self.current_attack:
        self.current_attack.kill()

    if self.opposite_attack:
        self.opposite_attack.kill()
    self.current_attack = None
    self.opposite_attack = None</code></pre>
</details>
</dd>
<dt id="level.Level.player_logic"><code class="name flex">
<span>def <span class="ident">player_logic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method handles the player logic. It checks for collisions between the player's attacks and the enemies,
and between the player and the collectable items. If a collision is detected, it calls the appropriate methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def player_logic(self):
    &#34;&#34;&#34;
    This method handles the player logic. It checks for collisions between the player&#39;s attacks and the enemies,
    and between the player and the collectable items. If a collision is detected, it calls the appropriate methods.
    &#34;&#34;&#34;

    if self.attack_sprites:
        for attack_sprite in self.attack_sprites:
            collision_sprites = pygame.sprite.spritecollide(attack_sprite, self.attackable_sprites, False)
            if collision_sprites:
                for target_sprite in collision_sprites:
                    target_sprite.get_damage(self.player, attack_sprite.sprite_type)
    if self.collectable_sprites:
        for collectable_sprite in self.collectable_sprites:
            collision_sprites = pygame.sprite.spritecollide(collectable_sprite, self.player_sprites, False)
            if collision_sprites:
                for target_sprite in collision_sprites:
                    self.player.health += 30
                    collectable_sprite.kill()
                    self.haps.play()</code></pre>
</details>
</dd>
<dt id="level.Level.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method runs the game logic. It updates the sprites, checks for player death and win, and draws the UI.
If the game is not paused, it continues the game logic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    This method runs the game logic. It updates the sprites, checks for player death and win, and draws the UI.
    If the game is not paused, it continues the game logic.
    &#34;&#34;&#34;

    self.visible_sprites.custom_draw(self.player)
    self.ui.draw(self.player)

    if not self.game_paused:  # Check if the game is not paused
        if not self.player.upgrade_performed:
            self.upgrade.display()
        else:
            # Continue the game logic
            if len(settings.enemies) == 0:
                settings.LEVEL += 1
                settings.WAVE_SIZE += 5
                for i in range(settings.WAVE_SIZE):
                    settings.enemies.append(choice(list(enemy_data.keys())))
                self.create_enemy()

                # Reset the upgrade flag in the player
                self.player.reset_upgrade_flag()

            self.visible_sprites.update()
            self.visible_sprites.enemy_update(self.player)
            self.player_logic()
            self.check_death()
            self.check_win()</code></pre>
</details>
</dd>
<dt id="level.Level.show_game_over"><code class="name flex">
<span>def <span class="ident">show_game_over</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method displays the game over screen. It fills the display surface with black, renders the game over text,
and plays the game over sound. It then waits for 5 seconds before quitting the game.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_game_over(self):
    &#34;&#34;&#34;
    This method displays the game over screen. It fills the display surface with black, renders the game over text,
    and plays the game over sound. It then waits for 5 seconds before quitting the game.
    &#34;&#34;&#34;

    game_over_font = pygame.font.Font(None, 100)
    game_over_text = game_over_font.render(&#34;Game Over&#34;, True, (255, 0, 0))
    game_over_rect = game_over_text.get_rect(center=(WIDTH // 2, HEIGHT // 2))

    self.display_surface.fill((0, 0, 0))
    self.display_surface.blit(game_over_text, game_over_rect)
    self.background_music.stop()
    self.gameOver.play()
    pygame.display.flip()

    # Wait for 5 seconds
    pygame.time.wait(5000)

    pygame.quit()
    sys.exit()</code></pre>
</details>
</dd>
<dt id="level.Level.show_win"><code class="name flex">
<span>def <span class="ident">show_win</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method displays the win screen. It fills the display surface with black, renders the win text,
and plays the victory sound. It then waits for 5 seconds before quitting the game.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_win(self):
    &#34;&#34;&#34;
    This method displays the win screen. It fills the display surface with black, renders the win text,
    and plays the victory sound. It then waits for 5 seconds before quitting the game.
    &#34;&#34;&#34;

    win_font = pygame.font.Font(UI_FONT, 100)
    win_text = win_font.render(&#34;You WON!!!&#34;, True, (0, 255, 0))
    win_rect = win_text.get_rect(center=(WIDTH // 2, HEIGHT // 2))

    self.display_surface.fill((0, 0, 0))
    self.display_surface.blit(win_text, win_rect)
    self.background_music.stop()
    self.victory.play()
    pygame.display.flip()

    # Wait for 5 seconds
    pygame.time.wait(5000)
    pygame.quit()
    sys.exit()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="level.YSortCameraGroup"><code class="flex name class">
<span>class <span class="ident">YSortCameraGroup</span></span>
</code></dt>
<dd>
<div class="desc"><p>The YSortCameraGroup class is a subclass of pygame.sprite.Group. It overrides the draw method to sort the sprites
by their y-coordinate before drawing them. This creates a depth effect, where sprites with a higher y-coordinate
(i.e., sprites that are lower on the screen) are drawn on top of sprites with a lower y-coordinate.</p>
<p>This method initializes a YSortCameraGroup object. It calls the superclass's <strong>init</strong> method and
sets up the display surface,
half width, half height, and offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class YSortCameraGroup(pygame.sprite.Group):
    &#34;&#34;&#34;
    The YSortCameraGroup class is a subclass of pygame.sprite.Group. It overrides the draw method to sort the sprites
    by their y-coordinate before drawing them. This creates a depth effect, where sprites with a higher y-coordinate
    (i.e., sprites that are lower on the screen) are drawn on top of sprites with a lower y-coordinate.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        This method initializes a YSortCameraGroup object. It calls the superclass&#39;s __init__ method and
        sets up the display surface,
        half width, half height, and offset.
        &#34;&#34;&#34;

        super().__init__()
        self.display_surface = pygame.display.get_surface()
        self.half_width = self.display_surface.get_rect().centerx
        self.half_height = self.display_surface.get_rect().centery
        self.offset = pygame.math.Vector2()

        # creating the floor
        self.floor_surface = pygame.image.load(&#39;graphics/map2.png&#39;).convert()
        self.floor_rect = self.floor_surface.get_rect(topleft=(0, 0))

    def custom_draw(self, player):
        &#34;&#34;&#34;
        This method draws the sprites in the group. It first draws the floor,
        then sorts the sprites by their y-coordinate and draws them.
        It also updates the offset based on the player&#39;s position.
        &#34;&#34;&#34;

        self.offset.x = player.rect.centerx - self.half_width
        self.offset.y = player.rect.centery - self.half_height

        # drawing the floor
        self.display_surface.blit(self.floor_surface, self.floor_rect.topleft - self.offset)

        for sprite in sorted(self.sprites(), key=lambda sprite: sprite.rect.centery):
            offset_pos = sprite.rect.topleft - self.offset
            self.display_surface.blit(sprite.image, offset_pos)

    def enemy_update(self, player):
        &#34;&#34;&#34;
        This method updates the enemies in the group.
        It gets the enemy sprites from the group and calls their enemy_update method.
        &#34;&#34;&#34;

        enemy_sprites = [sprite for sprite in self.sprites() if hasattr(sprite, &#39;sprite_type&#39;)
                         and sprite.sprite_type == &#39;enemy&#39;]
        for enemy in enemy_sprites:
            enemy.enemy_update(player)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygame.sprite.Group</li>
<li>pygame.sprite.AbstractGroup</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="level.YSortCameraGroup.custom_draw"><code class="name flex">
<span>def <span class="ident">custom_draw</span></span>(<span>self, player)</span>
</code></dt>
<dd>
<div class="desc"><p>This method draws the sprites in the group. It first draws the floor,
then sorts the sprites by their y-coordinate and draws them.
It also updates the offset based on the player's position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_draw(self, player):
    &#34;&#34;&#34;
    This method draws the sprites in the group. It first draws the floor,
    then sorts the sprites by their y-coordinate and draws them.
    It also updates the offset based on the player&#39;s position.
    &#34;&#34;&#34;

    self.offset.x = player.rect.centerx - self.half_width
    self.offset.y = player.rect.centery - self.half_height

    # drawing the floor
    self.display_surface.blit(self.floor_surface, self.floor_rect.topleft - self.offset)

    for sprite in sorted(self.sprites(), key=lambda sprite: sprite.rect.centery):
        offset_pos = sprite.rect.topleft - self.offset
        self.display_surface.blit(sprite.image, offset_pos)</code></pre>
</details>
</dd>
<dt id="level.YSortCameraGroup.enemy_update"><code class="name flex">
<span>def <span class="ident">enemy_update</span></span>(<span>self, player)</span>
</code></dt>
<dd>
<div class="desc"><p>This method updates the enemies in the group.
It gets the enemy sprites from the group and calls their enemy_update method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enemy_update(self, player):
    &#34;&#34;&#34;
    This method updates the enemies in the group.
    It gets the enemy sprites from the group and calls their enemy_update method.
    &#34;&#34;&#34;

    enemy_sprites = [sprite for sprite in self.sprites() if hasattr(sprite, &#39;sprite_type&#39;)
                     and sprite.sprite_type == &#39;enemy&#39;]
    for enemy in enemy_sprites:
        enemy.enemy_update(player)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="level.Level" href="#level.Level">Level</a></code></h4>
<ul class="two-column">
<li><code><a title="level.Level.check_death" href="#level.Level.check_death">check_death</a></code></li>
<li><code><a title="level.Level.check_win" href="#level.Level.check_win">check_win</a></code></li>
<li><code><a title="level.Level.create_attack" href="#level.Level.create_attack">create_attack</a></code></li>
<li><code><a title="level.Level.create_enemy" href="#level.Level.create_enemy">create_enemy</a></code></li>
<li><code><a title="level.Level.create_map" href="#level.Level.create_map">create_map</a></code></li>
<li><code><a title="level.Level.damage_player" href="#level.Level.damage_player">damage_player</a></code></li>
<li><code><a title="level.Level.destroy_weapon" href="#level.Level.destroy_weapon">destroy_weapon</a></code></li>
<li><code><a title="level.Level.player_logic" href="#level.Level.player_logic">player_logic</a></code></li>
<li><code><a title="level.Level.run" href="#level.Level.run">run</a></code></li>
<li><code><a title="level.Level.show_game_over" href="#level.Level.show_game_over">show_game_over</a></code></li>
<li><code><a title="level.Level.show_win" href="#level.Level.show_win">show_win</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="level.YSortCameraGroup" href="#level.YSortCameraGroup">YSortCameraGroup</a></code></h4>
<ul class="">
<li><code><a title="level.YSortCameraGroup.custom_draw" href="#level.YSortCameraGroup.custom_draw">custom_draw</a></code></li>
<li><code><a title="level.YSortCameraGroup.enemy_update" href="#level.YSortCameraGroup.enemy_update">enemy_update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>