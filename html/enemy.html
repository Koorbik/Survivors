<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>enemy API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>enemy</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pygame
from settings import *
from characters import Characters
from support import *


class Enemy(Characters):
    &#34;&#34;&#34;
    The Enemy class represents an enemy in the game. It is a subclass of Characters.
    It has methods for importing sprites, getting the player&#39;s location, getting the enemy&#39;s status,
    performing actions, getting damage, checking death, handling cooldowns, and updating the enemy.

    :param enemy_name: The name of the enemy.
    :param pos: The initial position of the enemy.
    :param groups: The groups that the enemy belongs to.
    :param obstacle_sprites: The sprites that represent obstacles.
    :param damage_player: The function to call to damage the player.
    &#34;&#34;&#34;

    def __init__(self, enemy_name, pos, groups, obstacle_sprites, damage_player):
        &#34;&#34;&#34;
        This method initializes an Enemy object. It calls the superclass&#39;s __init__ method and sets up the sprite type,
        graphics, movement, stats, player interaction, invincibility timer, and sounds.

        :param enemy_name: The name of the enemy.
        :param pos: The initial position of the enemy.
        :param groups: The groups that the enemy belongs to.
        :param obstacle_sprites: The sprites that represent obstacles.
        :param damage_player: The function to call to damage the player.
        &#34;&#34;&#34;
        super().__init__(groups)
        self.sprite_type = (&#39;enemy&#39;)

        # graphics
        self.import_sprites(enemy_name)
        self.status = &#39;move&#39;
        self.image = self.animations[self.status][self.frame_index]

        # movement
        self.rect = self.image.get_rect(topleft=pos)
        self.hitbox = self.rect.inflate(0, -10)
        self.obstacle_sprites = obstacle_sprites

        # stats
        self.enemy_name = enemy_name
        enemy_info = enemy_data[self.enemy_name]
        self.health = enemy_info[&#39;health&#39;]
        self.speed = enemy_info[&#39;speed&#39;]
        self.attack_damage = enemy_info[&#39;damage&#39;]
        self.resistance = enemy_info[&#39;resistance&#39;]
        self.attack_radius = enemy_info[&#39;attack_radius&#39;]

        # player interaction
        self.can_attack = True
        self.attack_time = None
        self.attack_cooldown = 400
        self.damage_player = damage_player

        # invincibility timer
        self.vulnerable = True
        self.hit_time = None
        self.invincibility_timer = 300

        # sounds
        self.death_sound = pygame.mixer.Sound(&#39;sounds/death.wav&#39;)
        self.hit_sound = pygame.mixer.Sound(&#39;sounds/hit.wav&#39;)
        self.death_sound.set_volume(0.05)
        self.hit_sound.set_volume(0.05)

    def import_sprites(self, name):
        &#34;&#34;&#34;
        This method imports the sprites for the enemy.
        It sets up the animations dictionary with the paths to the sprite images.

        :param name: The name of the enemy.
        &#34;&#34;&#34;
        self.animations = {&#39;move&#39;: [], &#39;attack&#39;: []}
        main_path = f&#39;graphics/enemies/{name}/&#39;
        for animation in self.animations.keys():
            self.animations[animation] = import_folder(main_path + animation)

    def get_player_location(self, player):
        &#34;&#34;&#34;
        This method gets the player&#39;s location relative to the enemy.
        It calculates the distance and direction from the enemy to the player.

        :param player: The player object.
        :return: The distance and direction from the enemy to the player.
        &#34;&#34;&#34;
        enemy_vector = pygame.math.Vector2(self.rect.center)
        player_vector = pygame.math.Vector2(player.rect.center)
        distance = (player_vector - enemy_vector).magnitude()
        if distance &gt; 0:
            direction = (player_vector - enemy_vector).normalize()
        else:
            direction = pygame.math.Vector2(0, 0)

        return (distance, direction)

    def get_status(self, player):
        &#34;&#34;&#34;
        This method gets the enemy&#39;s status.
        If the player is within the enemy&#39;s attack radius, the status is set to &#39;attack&#39;.
        Otherwise, the status is set to &#39;move&#39;.

        :param player: The player object.
        &#34;&#34;&#34;
        distance = self.get_player_location(player)[0]

        if distance &lt;= self.attack_radius:
            self.status = &#39;attack&#39;
        else:
            self.status = &#39;move&#39;

    def actions(self, player):
        &#34;&#34;&#34;
        This method performs the enemy&#39;s actions based on its status. If the status is &#39;attack&#39;, it damages the player.
        If the status is &#39;move&#39;, it sets the direction towards the player.

        :param player: The player object.
        &#34;&#34;&#34;
        if self.status == &#39;attack&#39;:
            self.attack_time = pygame.time.get_ticks()
            self.damage_player(self.attack_damage)
        elif self.status == &#39;move&#39;:
            self.direction = self.get_player_location(player)[1]

    def get_damage(self, player, attack_type):
        &#34;&#34;&#34;
        This method damages the enemy. If the enemy is vulnerable, it decreases the enemy&#39;s health based on
        the attack type and sets the enemy to be invulnerable.

        :param player: The player object.
        :param attack_type: The type of attack (&#39;weapon&#39; or &#39;projectile&#39;).
        &#34;&#34;&#34;
        if self.vulnerable:
            self.hit_sound.play()
            self.direction = self.get_player_location(player)[1]
            if attack_type == &#39;weapon&#39;:
                self.health -= player.get_full_attack_damage()
            else:
                pass

            self.hit_time = pygame.time.get_ticks()
            self.vulnerable = False

    def check_death(self):
        &#34;&#34;&#34;
        This method checks if the enemy has died. If the enemy&#39;s health is 0 or less,
        it removes the enemy from the enemies list, kills the enemy,
        and plays the death sound.
        &#34;&#34;&#34;
        if self.health &lt;= 0:
            if self.enemy_name in enemies:
                enemies.remove(self.enemy_name)
            self.kill()
            self.death_sound.play()

    def cooldowns(self):
        &#34;&#34;&#34;
        This method handles the enemy&#39;s cooldowns. If the enemy cannot attack, it checks
        if the attack cooldown has passed and allows the enemy to attack.
        If the enemy is not vulnerable, it checks if the invincibility timer has passed and makes the enemy vulnerable.
        &#34;&#34;&#34;
        current_time = pygame.time.get_ticks()
        if not self.can_attack:
            if current_time - self.attack_time &gt;= self.attack_cooldown:
                self.can_attack = True
        if not self.vulnerable:
            if current_time - self.hit_time &gt;= self.invincibility_timer:
                self.vulnerable = True

    def hit_reaction(self):
        &#34;&#34;&#34;
        This method handles the enemy&#39;s hit reaction. If the enemy is not vulnerable, it moves the enemy
        in the opposite direction based on its resistance.
        &#34;&#34;&#34;
        if not self.vulnerable:
            self.direction *= -self.resistance

    def update(self):
        &#34;&#34;&#34;
        This method updates the enemy. It handles the hit reaction, moves the enemy, handles cooldowns,
        and checks if the enemy has died.
        &#34;&#34;&#34;
        self.hit_reaction()
        self.move(self.speed)
        self.cooldowns()
        self.check_death()

    def enemy_update(self, player):
        &#34;&#34;&#34;
        This method updates the enemy based on the player. It gets the enemy&#39;s status, performs the enemy&#39;s actions,
        and updates the enemy.

        :param player: The player object.
        &#34;&#34;&#34;
        self.get_status(player)
        self.actions(player)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="enemy.Enemy"><code class="flex name class">
<span>class <span class="ident">Enemy</span></span>
<span>(</span><span>enemy_name, pos, groups, obstacle_sprites, damage_player)</span>
</code></dt>
<dd>
<div class="desc"><p>The Enemy class represents an enemy in the game. It is a subclass of Characters.
It has methods for importing sprites, getting the player's location, getting the enemy's status,
performing actions, getting damage, checking death, handling cooldowns, and updating the enemy.</p>
<p>:param enemy_name: The name of the enemy.
:param pos: The initial position of the enemy.
:param groups: The groups that the enemy belongs to.
:param obstacle_sprites: The sprites that represent obstacles.
:param damage_player: The function to call to damage the player.</p>
<p>This method initializes an Enemy object. It calls the superclass's <strong>init</strong> method and sets up the sprite type,
graphics, movement, stats, player interaction, invincibility timer, and sounds.</p>
<p>:param enemy_name: The name of the enemy.
:param pos: The initial position of the enemy.
:param groups: The groups that the enemy belongs to.
:param obstacle_sprites: The sprites that represent obstacles.
:param damage_player: The function to call to damage the player.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Enemy(Characters):
    &#34;&#34;&#34;
    The Enemy class represents an enemy in the game. It is a subclass of Characters.
    It has methods for importing sprites, getting the player&#39;s location, getting the enemy&#39;s status,
    performing actions, getting damage, checking death, handling cooldowns, and updating the enemy.

    :param enemy_name: The name of the enemy.
    :param pos: The initial position of the enemy.
    :param groups: The groups that the enemy belongs to.
    :param obstacle_sprites: The sprites that represent obstacles.
    :param damage_player: The function to call to damage the player.
    &#34;&#34;&#34;

    def __init__(self, enemy_name, pos, groups, obstacle_sprites, damage_player):
        &#34;&#34;&#34;
        This method initializes an Enemy object. It calls the superclass&#39;s __init__ method and sets up the sprite type,
        graphics, movement, stats, player interaction, invincibility timer, and sounds.

        :param enemy_name: The name of the enemy.
        :param pos: The initial position of the enemy.
        :param groups: The groups that the enemy belongs to.
        :param obstacle_sprites: The sprites that represent obstacles.
        :param damage_player: The function to call to damage the player.
        &#34;&#34;&#34;
        super().__init__(groups)
        self.sprite_type = (&#39;enemy&#39;)

        # graphics
        self.import_sprites(enemy_name)
        self.status = &#39;move&#39;
        self.image = self.animations[self.status][self.frame_index]

        # movement
        self.rect = self.image.get_rect(topleft=pos)
        self.hitbox = self.rect.inflate(0, -10)
        self.obstacle_sprites = obstacle_sprites

        # stats
        self.enemy_name = enemy_name
        enemy_info = enemy_data[self.enemy_name]
        self.health = enemy_info[&#39;health&#39;]
        self.speed = enemy_info[&#39;speed&#39;]
        self.attack_damage = enemy_info[&#39;damage&#39;]
        self.resistance = enemy_info[&#39;resistance&#39;]
        self.attack_radius = enemy_info[&#39;attack_radius&#39;]

        # player interaction
        self.can_attack = True
        self.attack_time = None
        self.attack_cooldown = 400
        self.damage_player = damage_player

        # invincibility timer
        self.vulnerable = True
        self.hit_time = None
        self.invincibility_timer = 300

        # sounds
        self.death_sound = pygame.mixer.Sound(&#39;sounds/death.wav&#39;)
        self.hit_sound = pygame.mixer.Sound(&#39;sounds/hit.wav&#39;)
        self.death_sound.set_volume(0.05)
        self.hit_sound.set_volume(0.05)

    def import_sprites(self, name):
        &#34;&#34;&#34;
        This method imports the sprites for the enemy.
        It sets up the animations dictionary with the paths to the sprite images.

        :param name: The name of the enemy.
        &#34;&#34;&#34;
        self.animations = {&#39;move&#39;: [], &#39;attack&#39;: []}
        main_path = f&#39;graphics/enemies/{name}/&#39;
        for animation in self.animations.keys():
            self.animations[animation] = import_folder(main_path + animation)

    def get_player_location(self, player):
        &#34;&#34;&#34;
        This method gets the player&#39;s location relative to the enemy.
        It calculates the distance and direction from the enemy to the player.

        :param player: The player object.
        :return: The distance and direction from the enemy to the player.
        &#34;&#34;&#34;
        enemy_vector = pygame.math.Vector2(self.rect.center)
        player_vector = pygame.math.Vector2(player.rect.center)
        distance = (player_vector - enemy_vector).magnitude()
        if distance &gt; 0:
            direction = (player_vector - enemy_vector).normalize()
        else:
            direction = pygame.math.Vector2(0, 0)

        return (distance, direction)

    def get_status(self, player):
        &#34;&#34;&#34;
        This method gets the enemy&#39;s status.
        If the player is within the enemy&#39;s attack radius, the status is set to &#39;attack&#39;.
        Otherwise, the status is set to &#39;move&#39;.

        :param player: The player object.
        &#34;&#34;&#34;
        distance = self.get_player_location(player)[0]

        if distance &lt;= self.attack_radius:
            self.status = &#39;attack&#39;
        else:
            self.status = &#39;move&#39;

    def actions(self, player):
        &#34;&#34;&#34;
        This method performs the enemy&#39;s actions based on its status. If the status is &#39;attack&#39;, it damages the player.
        If the status is &#39;move&#39;, it sets the direction towards the player.

        :param player: The player object.
        &#34;&#34;&#34;
        if self.status == &#39;attack&#39;:
            self.attack_time = pygame.time.get_ticks()
            self.damage_player(self.attack_damage)
        elif self.status == &#39;move&#39;:
            self.direction = self.get_player_location(player)[1]

    def get_damage(self, player, attack_type):
        &#34;&#34;&#34;
        This method damages the enemy. If the enemy is vulnerable, it decreases the enemy&#39;s health based on
        the attack type and sets the enemy to be invulnerable.

        :param player: The player object.
        :param attack_type: The type of attack (&#39;weapon&#39; or &#39;projectile&#39;).
        &#34;&#34;&#34;
        if self.vulnerable:
            self.hit_sound.play()
            self.direction = self.get_player_location(player)[1]
            if attack_type == &#39;weapon&#39;:
                self.health -= player.get_full_attack_damage()
            else:
                pass

            self.hit_time = pygame.time.get_ticks()
            self.vulnerable = False

    def check_death(self):
        &#34;&#34;&#34;
        This method checks if the enemy has died. If the enemy&#39;s health is 0 or less,
        it removes the enemy from the enemies list, kills the enemy,
        and plays the death sound.
        &#34;&#34;&#34;
        if self.health &lt;= 0:
            if self.enemy_name in enemies:
                enemies.remove(self.enemy_name)
            self.kill()
            self.death_sound.play()

    def cooldowns(self):
        &#34;&#34;&#34;
        This method handles the enemy&#39;s cooldowns. If the enemy cannot attack, it checks
        if the attack cooldown has passed and allows the enemy to attack.
        If the enemy is not vulnerable, it checks if the invincibility timer has passed and makes the enemy vulnerable.
        &#34;&#34;&#34;
        current_time = pygame.time.get_ticks()
        if not self.can_attack:
            if current_time - self.attack_time &gt;= self.attack_cooldown:
                self.can_attack = True
        if not self.vulnerable:
            if current_time - self.hit_time &gt;= self.invincibility_timer:
                self.vulnerable = True

    def hit_reaction(self):
        &#34;&#34;&#34;
        This method handles the enemy&#39;s hit reaction. If the enemy is not vulnerable, it moves the enemy
        in the opposite direction based on its resistance.
        &#34;&#34;&#34;
        if not self.vulnerable:
            self.direction *= -self.resistance

    def update(self):
        &#34;&#34;&#34;
        This method updates the enemy. It handles the hit reaction, moves the enemy, handles cooldowns,
        and checks if the enemy has died.
        &#34;&#34;&#34;
        self.hit_reaction()
        self.move(self.speed)
        self.cooldowns()
        self.check_death()

    def enemy_update(self, player):
        &#34;&#34;&#34;
        This method updates the enemy based on the player. It gets the enemy&#39;s status, performs the enemy&#39;s actions,
        and updates the enemy.

        :param player: The player object.
        &#34;&#34;&#34;
        self.get_status(player)
        self.actions(player)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>characters.Characters</li>
<li>pygame.sprite.Sprite</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="enemy.Enemy.actions"><code class="name flex">
<span>def <span class="ident">actions</span></span>(<span>self, player)</span>
</code></dt>
<dd>
<div class="desc"><p>This method performs the enemy's actions based on its status. If the status is 'attack', it damages the player.
If the status is 'move', it sets the direction towards the player.</p>
<p>:param player: The player object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def actions(self, player):
    &#34;&#34;&#34;
    This method performs the enemy&#39;s actions based on its status. If the status is &#39;attack&#39;, it damages the player.
    If the status is &#39;move&#39;, it sets the direction towards the player.

    :param player: The player object.
    &#34;&#34;&#34;
    if self.status == &#39;attack&#39;:
        self.attack_time = pygame.time.get_ticks()
        self.damage_player(self.attack_damage)
    elif self.status == &#39;move&#39;:
        self.direction = self.get_player_location(player)[1]</code></pre>
</details>
</dd>
<dt id="enemy.Enemy.check_death"><code class="name flex">
<span>def <span class="ident">check_death</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method checks if the enemy has died. If the enemy's health is 0 or less,
it removes the enemy from the enemies list, kills the enemy,
and plays the death sound.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_death(self):
    &#34;&#34;&#34;
    This method checks if the enemy has died. If the enemy&#39;s health is 0 or less,
    it removes the enemy from the enemies list, kills the enemy,
    and plays the death sound.
    &#34;&#34;&#34;
    if self.health &lt;= 0:
        if self.enemy_name in enemies:
            enemies.remove(self.enemy_name)
        self.kill()
        self.death_sound.play()</code></pre>
</details>
</dd>
<dt id="enemy.Enemy.cooldowns"><code class="name flex">
<span>def <span class="ident">cooldowns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method handles the enemy's cooldowns. If the enemy cannot attack, it checks
if the attack cooldown has passed and allows the enemy to attack.
If the enemy is not vulnerable, it checks if the invincibility timer has passed and makes the enemy vulnerable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cooldowns(self):
    &#34;&#34;&#34;
    This method handles the enemy&#39;s cooldowns. If the enemy cannot attack, it checks
    if the attack cooldown has passed and allows the enemy to attack.
    If the enemy is not vulnerable, it checks if the invincibility timer has passed and makes the enemy vulnerable.
    &#34;&#34;&#34;
    current_time = pygame.time.get_ticks()
    if not self.can_attack:
        if current_time - self.attack_time &gt;= self.attack_cooldown:
            self.can_attack = True
    if not self.vulnerable:
        if current_time - self.hit_time &gt;= self.invincibility_timer:
            self.vulnerable = True</code></pre>
</details>
</dd>
<dt id="enemy.Enemy.enemy_update"><code class="name flex">
<span>def <span class="ident">enemy_update</span></span>(<span>self, player)</span>
</code></dt>
<dd>
<div class="desc"><p>This method updates the enemy based on the player. It gets the enemy's status, performs the enemy's actions,
and updates the enemy.</p>
<p>:param player: The player object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enemy_update(self, player):
    &#34;&#34;&#34;
    This method updates the enemy based on the player. It gets the enemy&#39;s status, performs the enemy&#39;s actions,
    and updates the enemy.

    :param player: The player object.
    &#34;&#34;&#34;
    self.get_status(player)
    self.actions(player)</code></pre>
</details>
</dd>
<dt id="enemy.Enemy.get_damage"><code class="name flex">
<span>def <span class="ident">get_damage</span></span>(<span>self, player, attack_type)</span>
</code></dt>
<dd>
<div class="desc"><p>This method damages the enemy. If the enemy is vulnerable, it decreases the enemy's health based on
the attack type and sets the enemy to be invulnerable.</p>
<p>:param player: The player object.
:param attack_type: The type of attack ('weapon' or 'projectile').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_damage(self, player, attack_type):
    &#34;&#34;&#34;
    This method damages the enemy. If the enemy is vulnerable, it decreases the enemy&#39;s health based on
    the attack type and sets the enemy to be invulnerable.

    :param player: The player object.
    :param attack_type: The type of attack (&#39;weapon&#39; or &#39;projectile&#39;).
    &#34;&#34;&#34;
    if self.vulnerable:
        self.hit_sound.play()
        self.direction = self.get_player_location(player)[1]
        if attack_type == &#39;weapon&#39;:
            self.health -= player.get_full_attack_damage()
        else:
            pass

        self.hit_time = pygame.time.get_ticks()
        self.vulnerable = False</code></pre>
</details>
</dd>
<dt id="enemy.Enemy.get_player_location"><code class="name flex">
<span>def <span class="ident">get_player_location</span></span>(<span>self, player)</span>
</code></dt>
<dd>
<div class="desc"><p>This method gets the player's location relative to the enemy.
It calculates the distance and direction from the enemy to the player.</p>
<p>:param player: The player object.
:return: The distance and direction from the enemy to the player.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_player_location(self, player):
    &#34;&#34;&#34;
    This method gets the player&#39;s location relative to the enemy.
    It calculates the distance and direction from the enemy to the player.

    :param player: The player object.
    :return: The distance and direction from the enemy to the player.
    &#34;&#34;&#34;
    enemy_vector = pygame.math.Vector2(self.rect.center)
    player_vector = pygame.math.Vector2(player.rect.center)
    distance = (player_vector - enemy_vector).magnitude()
    if distance &gt; 0:
        direction = (player_vector - enemy_vector).normalize()
    else:
        direction = pygame.math.Vector2(0, 0)

    return (distance, direction)</code></pre>
</details>
</dd>
<dt id="enemy.Enemy.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self, player)</span>
</code></dt>
<dd>
<div class="desc"><p>This method gets the enemy's status.
If the player is within the enemy's attack radius, the status is set to 'attack'.
Otherwise, the status is set to 'move'.</p>
<p>:param player: The player object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_status(self, player):
    &#34;&#34;&#34;
    This method gets the enemy&#39;s status.
    If the player is within the enemy&#39;s attack radius, the status is set to &#39;attack&#39;.
    Otherwise, the status is set to &#39;move&#39;.

    :param player: The player object.
    &#34;&#34;&#34;
    distance = self.get_player_location(player)[0]

    if distance &lt;= self.attack_radius:
        self.status = &#39;attack&#39;
    else:
        self.status = &#39;move&#39;</code></pre>
</details>
</dd>
<dt id="enemy.Enemy.hit_reaction"><code class="name flex">
<span>def <span class="ident">hit_reaction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method handles the enemy's hit reaction. If the enemy is not vulnerable, it moves the enemy
in the opposite direction based on its resistance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hit_reaction(self):
    &#34;&#34;&#34;
    This method handles the enemy&#39;s hit reaction. If the enemy is not vulnerable, it moves the enemy
    in the opposite direction based on its resistance.
    &#34;&#34;&#34;
    if not self.vulnerable:
        self.direction *= -self.resistance</code></pre>
</details>
</dd>
<dt id="enemy.Enemy.import_sprites"><code class="name flex">
<span>def <span class="ident">import_sprites</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>This method imports the sprites for the enemy.
It sets up the animations dictionary with the paths to the sprite images.</p>
<p>:param name: The name of the enemy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_sprites(self, name):
    &#34;&#34;&#34;
    This method imports the sprites for the enemy.
    It sets up the animations dictionary with the paths to the sprite images.

    :param name: The name of the enemy.
    &#34;&#34;&#34;
    self.animations = {&#39;move&#39;: [], &#39;attack&#39;: []}
    main_path = f&#39;graphics/enemies/{name}/&#39;
    for animation in self.animations.keys():
        self.animations[animation] = import_folder(main_path + animation)</code></pre>
</details>
</dd>
<dt id="enemy.Enemy.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method updates the enemy. It handles the hit reaction, moves the enemy, handles cooldowns,
and checks if the enemy has died.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;
    This method updates the enemy. It handles the hit reaction, moves the enemy, handles cooldowns,
    and checks if the enemy has died.
    &#34;&#34;&#34;
    self.hit_reaction()
    self.move(self.speed)
    self.cooldowns()
    self.check_death()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="enemy.Enemy" href="#enemy.Enemy">Enemy</a></code></h4>
<ul class="two-column">
<li><code><a title="enemy.Enemy.actions" href="#enemy.Enemy.actions">actions</a></code></li>
<li><code><a title="enemy.Enemy.check_death" href="#enemy.Enemy.check_death">check_death</a></code></li>
<li><code><a title="enemy.Enemy.cooldowns" href="#enemy.Enemy.cooldowns">cooldowns</a></code></li>
<li><code><a title="enemy.Enemy.enemy_update" href="#enemy.Enemy.enemy_update">enemy_update</a></code></li>
<li><code><a title="enemy.Enemy.get_damage" href="#enemy.Enemy.get_damage">get_damage</a></code></li>
<li><code><a title="enemy.Enemy.get_player_location" href="#enemy.Enemy.get_player_location">get_player_location</a></code></li>
<li><code><a title="enemy.Enemy.get_status" href="#enemy.Enemy.get_status">get_status</a></code></li>
<li><code><a title="enemy.Enemy.hit_reaction" href="#enemy.Enemy.hit_reaction">hit_reaction</a></code></li>
<li><code><a title="enemy.Enemy.import_sprites" href="#enemy.Enemy.import_sprites">import_sprites</a></code></li>
<li><code><a title="enemy.Enemy.update" href="#enemy.Enemy.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>